"""
Number theory functions.
"""
import sys

from functools import reduce
from itertools import count
from math import sqrt, gcd
from operator import mul


def prod(seq):
    return reduce(mul, seq, 1)


def is_prime(n):
    if n < 2 or n%2==0:
        return n==2
    for m in range(3,int(sqrt(n))+1,2):
        if n%m==0:
            return False
    return True


def primes_less_than(n):
    primes = []
    for m in range(2,n):
        found_prime = True
        for p in primes:
            if p*p > m:
                break
            if m % p == 0:
                found_prime = False
                break
        if found_prime:
            primes.append(m)
    return primes


def primes():
    """
    Generate prime numbers
    """
    primes = []
    for n in count(2):
        found_prime = True
        for p in primes:
            if p*p > n:
                break
            if n % p == 0:
                found_prime = False
                break
        if found_prime:
            primes.append(n)
            yield n


def even(n):
    return n%2 == 0


def odd(n):
    return n%2 == 1


def factor(n):
    """
    Factor an integer n returning a list of prime factors
    """
    f = 2
    fs = iter(range(3, int(sqrt(n))+1, 2))

    factors = []
    r = n
    try:
        while r > 1:
            while r%f==0:
                r = r//f
                factors.append(f)
            f = next(fs)
    except StopIteration:
        if r > 1:
            factors.append(r)
    return factors


def test_factor():
    assert factor(100) == [2,2,5,5]
    assert factor(23)  == [23]
    assert factor(871) == [13,67]
    assert factor(40)  == [2, 2, 2, 5]
    assert factor(2*3*5*7*11*13*17*19*23*29*31) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]


def collatz_sequence(n):
    """
    The Collatz sequence for n is a generated by iterating:

    a_n = (1/2) * a_n-1    if a_n-1 is even
    a_n = 3*a_n-1 + 1      if a_n-1 is odd

    ...a sequence which is conjectured to always wind up at 1.
    """
    s = []
    x = n
    while x>1:
        s.append(x)
        if x % 2 == 0:
            x = x//2
        else:
            x = 3*x + 1
    return s


def test_collatz_sequence():
    for n in range(1,100):
        print(collatz_sequence(n))

    print(max(len(collatz_sequence(n)) for n in range(1000)))


def euler_phi(n):
    return sum(gcd(n, k) == 1 for k in range(1, n + 1))


def order_g_mod_m(g, m):
    for x in range(1, m):
        if pow(g, x, m) == 1:
            break
    return x


def primitive_roots(m):
    phi = euler_phi(m)
    return [g for g in range(2, m) if order_g_mod_m(g, m) == phi]


def is_primitive_root(a, m):
    return order_g_mod_m(a, m) == euler_phi(m)


def primitive_root_permutations(m):
    phi = euler_phi(m)

    return [
        [pow(a, x, m) for x in range(1, m)]
            for a in range(2, m)
                if order_g_mod_m(a, m) == phi]
